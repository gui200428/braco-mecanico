<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="./style.css">
    <title>Controle</title>
</head>

<body>
    <h1 style="display: flex; align-items: center; justify-content: center; padding: 20px;">CONTROLE</h1>

    <div class="controller">
        <div class="left">
            <div class="triggers">
                <div class="triggerL2" id="L2">L2</div>
                <div class="triggerL1" id="L1">L1</div>
            </div>
            <div class="crossCenter">
                <div class="crossUp" id="crossUp"></div>
                <div class="crossDown" id="crossDown"></div>
                <div class="crossLeft" id="crossLeft"></div>
                <div class="crossRight" id="crossRight"></div>
                <div class="crossCircle"></div>
            </div>
        </div>
        <div class="right">
            <div class="triggers" id="triggersRight">
                <div class="triggerR2">R2</div>
                <div class="triggerR1">R1</div>
            </div>
            <div class="ButtonsCenter">
                <div class="button-row">
                    <div class="x">X</div>
                    <div class="y">Y</div>
                    <div class="b">B</div>
                </div>
                <div class="button-row">
                    <div class="a">A</div>
                    <div class="g">G</div>
                </div>
            </div>
        </div>
    </div>

    <script src="/socket.io/socket.io.js"></script>
    <script>
        const socket = io();

        // Variáveis do acelerômetro
        let alpha = 0;
        let beta = 0;
        let gamma = 0;

        // Toggles
        let toggleStateL2 = false; // Estado inicial do toggle, false significa enviar alpha, beta, gamma
        let toggleStateL1 = false; // True significa não enviar crossleft e crossright
        let toggleStateB = false;  // True significa B está ativo, desabilitar crossleft e crossright
        let toggleStateY = false;  // True significa Y está ativo, desabilitar crossup e crossdown
        let toggleStateG = false;  // True significa G está ativo, desabilitar crossleft e crossright
        let toggleStateX = false;  // True significa X está ativo, desabilitar crossleft e crossright

        // Botões do controle
        const l1Button = document.getElementById('L1');
        const l2Button = document.getElementById('L2');
        const r1Button = document.getElementById('R1');
        const r2Button = document.getElementById('R2');
        const crossUp = document.getElementById('crossUp');
        const crossDown = document.getElementById('crossDown');
        const crossLeft = document.getElementById('crossLeft');
        const crossRight = document.getElementById('crossRight');
        const xButton = document.querySelector('.x');
        const yButton = document.querySelector('.y');
        const bButton = document.querySelector('.b');
        const aButton = document.querySelector('.a');
        const gButton = document.querySelector('.g');

        // Verificação de suporte ao DeviceOrientationEvent
        if (window.DeviceOrientationEvent) {
            window.addEventListener('deviceorientation', handleOrientationEvent);
            setInterval(() => socket.emit('ping'), 30000);
        } else {
            alert("DeviceOrientationEvent não é suportado no seu dispositivo.");
        }

        // Função para tratar eventos de orientação
        function handleOrientationEvent(event) {
            if (!toggleStateL2) {
                const orientationData = {
                    alpha: Math.round(event.alpha),
                    beta: Math.round(event.beta),
                    gamma: Math.round(event.gamma)
                };

                if (orientationData.alpha !== alpha || orientationData.beta !== beta || orientationData.gamma !== gamma) {
                    socket.emit('orientationData', orientationData);
                    alpha = orientationData.alpha;
                    beta = orientationData.beta;
                    gamma = orientationData.gamma;
                }
            }
        }



        // Eventos para alternar estados
        l2Button.addEventListener('click', () => {
            toggleStateL2 = !toggleStateL2;
            l2Button.style.backgroundColor = toggleStateL2 ? 'red' : '#484848';
        });

        l1Button.addEventListener('click', () => {
            toggleStateL1 = !toggleStateL1;
            crossLeft.classList.toggle('disabled', toggleStateL1 || toggleStateB);
            crossRight.classList.toggle('disabled', toggleStateL1 || toggleStateB);
        });

        // Função para enviar os dados do botão L1
        l1Button.addEventListener('mousedown', function () {
            if (toggleStateL2) {
                socket.emit('buttonData', { button: 'L1' });
            }
        });

        // Evento de clique para o botão B (toggle)
        bButton.addEventListener('click', () => {
            toggleStateB = !toggleStateB;
            bButton.style.backgroundColor = toggleStateB ? 'green' : '#484848';
            crossLeft.classList.toggle('disabled', toggleStateB);
            crossRight.classList.toggle('disabled', toggleStateB);
        });

        yButton.addEventListener('click', () => {
            toggleStateY = !toggleStateY;
            yButton.style.backgroundColor = toggleStateY ? '#77DD77' : '#484848';
            crossUp.classList.toggle('disabled', toggleStateY);
            crossDown.classList.toggle('disabled', toggleStateY);
        });

        gButton.addEventListener('click', () => {
            toggleStateG = !toggleStateG;
            gButton.style.backgroundColor = toggleStateG ? '#9370DB' : '#484848';
            crossLeft.classList.toggle('disabled', toggleStateG);
            crossRight.classList.toggle('disabled', toggleStateG);
        });

        xButton.addEventListener('click', () => {
            toggleStateX = !toggleStateX;
            xButton.style.backgroundColor = toggleStateX ? '#FFA07A' : '#484848';
            crossLeft.classList.toggle('disabled', toggleStateX);
            crossRight.classList.toggle('disabled', toggleStateX);
        });


        // Controle A B X Y
        function sendButtonData(button) {
            if (button === 'b') {
                return;
            }
            if (button === 'y') {
                return;
            }
            else {
                socket.emit('buttonData', { button });
            }
        }

        // Controle cruz


        // Função para enviar dados do direcional
        function sendCrossData(direction) {
            if (toggleStateL2) { // Verifica se o toggleState está ativo
                // Desativa rotação da base quando L1 (base) está ativo (TODO: Testar melhor quando base for implementada)
                if (toggleStateL1 && (direction === 'crossLeft' || direction === 'crossRight')) {
                    return;
                }
                // Desativa os botões quando B (art3) está ativo
                if (toggleStateB && (direction === 'crossLeft' || direction === 'crossRight')) {
                    return;
                }
                // Muda a direção para UpArt3 ou DownArt3 quando B (art3) está ativo
                if (toggleStateB && (direction === 'crossUp' || direction === 'crossDown')) {
                    const action = direction === 'crossUp' ? 'UpArt3' : 'DownArt3';
                    socket.emit('crossData', { direction: action });
                }
                // Desativa os botões quando Y (pulso) está ativo
                if (toggleStateY && (direction === 'crossUp' || direction === 'crossDown')) {
                    return; // Não envia se for crossUp ou crossDown e toggleStateY for true
                }
                // Muda a direção para LeftPulso ou RightPulso quando Y (pulso) está ativo
                if (toggleStateY && (direction === 'crossLeft' || direction === 'crossRight')) {
                    const action = direction === 'crossLeft' ? 'LeftPulso' : 'RightPulso';
                    socket.emit('crossData', { direction: action });
                }
                // Desativa os botões quando G (garra) está ativo
                if (toggleStateG && (direction === 'crossLeft' || direction === 'crossRight')) {
                    return; // Não envia se for crossLeft ou crossRight e toggleStateG for true
                }
                // Muda a direção para UpArt2 ou DownArt2 quando G (art2) está ativo
                if (toggleStateG && (direction === 'crossUp' || direction === 'crossDown')) {
                    const action = direction === 'crossUp' ? 'UpArt2' : 'DownArt2';
                    socket.emit('crossData', { direction: action });
                }
                // Desativa os botões quando X (art1) está ativo
                if (toggleStateX && (direction === 'crossLeft' || direction === 'crossRight')) {
                    return; // Não envia se for crossLeft ou crossRight e toggleStateX for true
                }
                // Muda a direção para UpArt1 ou DownArt1 quando X (art1) está ativo
                if (toggleStateX && (direction === 'crossUp' || direction === 'crossDown')) {
                    const action = direction === 'crossUp' ? 'UpArt1' : 'DownArt1';
                    socket.emit('crossData', { direction: action });
                }

                else {
                    // Muda os valores de crossLeft e crossRight para LeftBase e RightBase quando L2 (base) está ativo

                    socket.emit('crossData', { direction: direction });
                }
            }
        }



        // Eventos de clique para botões de direção
        const crossSides = document.querySelectorAll('.crossCenter > div');
        crossSides.forEach(side => {
            side.addEventListener('mousedown', function () {
                if (toggleStateL2) {
                    sendCrossData(this.id);
                    crossSides.forEach(el => el.classList.remove('cross-clicked'));
                    this.classList.add('cross-clicked');
                }
            });

            side.addEventListener('mouseup', function () {
                this.classList.remove('cross-clicked');
            });
        });

        // Eventos de clique para botões triggers
        const buttonSides = document.querySelectorAll('.triggers > div');
        buttonSides.forEach(button => {
            button.addEventListener('mousedown', function () {
                buttonSides.forEach(el => el.classList.remove('button-clicked'));
                this.classList.add('button-clicked');
            });

            button.addEventListener('mouseup', function () {
                this.classList.remove('button-clicked');
            });
        });


        // Eventos de clique para botões X, Y, B, A, G
        [xButton, yButton, bButton, aButton, gButton].forEach(button => {
            button.addEventListener('mousedown', function () {
                button.classList.add(`${button.classList[0]}-clicked`);
                sendButtonData(button.classList[0]);
            });

            button.addEventListener('mouseup', function () {
                button.classList.remove(`${button.classList[0]}-clicked`);
            });
        });

    </script>
</body>

</html>